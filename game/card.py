# =============================================================================
# card.py - カードの定義
# =============================================================================
#
# このファイルでは、ゲームで使用する「カード」を定義しています。
# 
# 【このファイルで学べること】
# - クラス（class）の基本的な使い方
# - 継承（inheritance）の概念
# - インスタンス変数とクラス変数の違い
# - メソッド（関数）の定義方法
#
# =============================================================================


# =============================================================================
# CardType クラス - カードの種類を表す定数
# =============================================================================
class CardType:
    """
    カードの種類を定義するクラスです。
    
    【解説】
    このクラスは「定数の集まり」として使っています。
    Pythonには組み込みの定数機能がないため、クラス変数を使って
    定数のように扱う値をまとめています。
    
    【使用例】
    card_type = CardType.ATTACK  # "attack" という文字列が入る
    """
    
    # クラス変数の定義
    # これらはCardTypeクラス全体で共有される値です
    ATTACK = "attack"      # 攻撃カード：敵にダメージを与える
    DEFEND = "defend"      # 防御カード：自分にブロック（シールド）を付与
    SKILL = "skill"        # スキルカード：様々な特殊効果を発動


# =============================================================================
# Card クラス - カードの基本クラス
# =============================================================================
class Card:
    """
    カードの基本となるクラスです。
    
    【解説】
    このクラスは「すべてのカードが持つ共通の特徴」を定義しています。
    具体的なカード（攻撃カードや防御カードなど）は、このクラスを
    「継承」して作成します。
    
    【クラスとは？】
    クラスは「設計図」のようなものです。
    例えば「カード」という設計図から、「炎の剣カード」「氷の盾カード」
    などの具体的なカード（インスタンス）を作成できます。
    
    【継承とは？】
    既存のクラスの機能を引き継いで、新しいクラスを作ることです。
    親クラス（Card）の機能を子クラス（AttackCardなど）が受け継ぎます。
    """
    
    def __init__(self, name, description, cost, card_type):
        """
        コンストラクタ - カードが作成されるときに呼ばれるメソッド
        
        【引数の説明】
        - self: 作成されるインスタンス自身を指します（Pythonの決まりごと）
        - name: カードの名前（例："炎の剣"）
        - description: カードの説明文（例："敵に10ダメージを与える"）
        - cost: カードを使用するのに必要なエネルギー量
        - card_type: カードの種類（CardType.ATTACKなど）
        
        【__init__メソッドとは？】
        クラスからインスタンスを作成するときに自動的に呼ばれる特別なメソッドです。
        インスタンスの初期設定を行います。
        
        【実行内容】
        このメソッドでは、引数で受け取った値をインスタンス変数に保存しています。
        """
        # self.変数名 = 値 の形式でインスタンス変数を定義します
        # インスタンス変数は、各カードインスタンスごとに別々の値を持ちます
        self.name = name                  # カードの名前を保存
        self.description = description    # カードの説明文を保存
        self.cost = cost                  # 使用コストを保存
        self.card_type = card_type        # カードの種類を保存
    
    def use(self, user, target):
        """
        カードを使用するときに呼ばれるメソッド
        
        【引数の説明】
        - self: このカード自身
        - user: カードを使用するキャラクター（プレイヤーまたは敵）
        - target: カードの効果の対象となるキャラクター
        
        【戻り値】
        - 文字列: カードを使用した結果のメッセージ
        
        【実行内容】
        この基本クラスでは、単純に使用メッセージを返すだけです。
        子クラス（AttackCardなど）でこのメソッドを「オーバーライド」
        （上書き）して、具体的な効果を実装します。
        
        【オーバーライドとは？】
        親クラスで定義されたメソッドを、子クラスで再定義することです。
        子クラスで再定義すると、子クラスのメソッドが優先されます。
        """
        # f文字列を使って、カード名を含むメッセージを作成
        # f"..." の中で {変数名} と書くと、変数の値が埋め込まれます
        return f"{self.name}を使用した！"
    
    def __str__(self):
        """
        カードを文字列として表現するメソッド
        
        【解説】
        __str__は特殊メソッド（マジックメソッド）の一つです。
        print(card) のようにカードを表示しようとしたときに
        自動的に呼ばれます。
        
        【戻り値】
        - 文字列: カードの情報を見やすく整形した文字列
        
        【実行内容】
        カードの名前、コスト、説明を見やすい形式で返します。
        """
        return f"[{self.name}] コスト:{self.cost} - {self.description}"


# =============================================================================
# AttackCard クラス - 攻撃カード
# =============================================================================
class AttackCard(Card):
    """
    攻撃用のカードを表すクラスです。
    
    【解説】
    Card クラスを継承しています。
    class AttackCard(Card): の (Card) の部分が「継承」を示しています。
    
    これにより、Card クラスの全ての機能（name, description, cost, card_type、
    __str__メソッドなど）を引き継ぎつつ、攻撃カード固有の機能を追加できます。
    """
    
    def __init__(self, name, description, cost, damage):
        """
        攻撃カードのコンストラクタ
        
        【引数の説明】
        - name: カードの名前
        - description: カードの説明文
        - cost: 使用コスト
        - damage: このカードが与えるダメージ量
        
        【実行内容】
        1. 親クラス（Card）のコンストラクタを呼び出して、共通の初期化を行う
        2. 攻撃カード固有の変数（damage）を設定する
        """
        # super() は親クラス（Card）を指します
        # super().__init__(...) で親クラスのコンストラクタを呼び出します
        # これにより、name, description, cost, card_type が設定されます
        super().__init__(name, description, cost, CardType.ATTACK)
        
        # 攻撃カード固有の属性：与えるダメージ量
        self.damage = damage
    
    def use(self, user, target):
        """
        攻撃カードを使用するメソッド
        
        【引数の説明】
        - user: カードを使用するキャラクター
        - target: 攻撃対象となるキャラクター
        
        【戻り値】
        - 文字列: 攻撃結果のメッセージ
        
        【実行内容】
        1. 対象にダメージを与える
        2. 結果のメッセージを返す
        
        【オーバーライド】
        親クラス（Card）の use メソッドを上書きしています。
        これにより、攻撃カード固有の処理を実行できます。
        """
        # target.receive_damage() を呼び出して、対象にダメージを与える
        # receive_damage() メソッドは character.py で定義されています
        target.receive_damage(self.damage)
        
        # 攻撃結果のメッセージを作成して返す
        return f"{user.name}は{self.name}を使った！{target.name}に{self.damage}ダメージ！"


# =============================================================================
# DefendCard クラス - 防御カード
# =============================================================================
class DefendCard(Card):
    """
    防御用のカードを表すクラスです。
    
    【解説】
    ブロック（シールド）を付与することで、次に受けるダメージを軽減します。
    ブロックはターン終了時にリセットされます（通常のローグライク系の仕様）。
    """
    
    def __init__(self, name, description, cost, block):
        """
        防御カードのコンストラクタ
        
        【引数の説明】
        - name: カードの名前
        - description: カードの説明文
        - cost: 使用コスト
        - block: このカードが付与するブロック量
        
        【実行内容】
        1. 親クラス（Card）のコンストラクタを呼び出す
        2. 防御カード固有の変数（block）を設定する
        """
        super().__init__(name, description, cost, CardType.DEFEND)
        self.block = block
    
    def use(self, user, target):
        """
        防御カードを使用するメソッド
        
        【引数の説明】
        - user: カードを使用するキャラクター（ブロックを得る側）
        - target: この場合は使用されない（防御は自分に効果がある）
        
        【戻り値】
        - 文字列: 防御結果のメッセージ
        
        【実行内容】
        1. 使用者にブロックを付与する
        2. 結果のメッセージを返す
        """
        # user.gain_block() を呼び出して、使用者にブロックを付与
        user.gain_block(self.block)
        
        return f"{user.name}は{self.name}を使った！{self.block}ブロックを獲得！"


# =============================================================================
# SkillCard クラス - スキルカード
# =============================================================================
class SkillCard(Card):
    """
    特殊効果を持つスキルカードを表すクラスです。
    
    【解説】
    スキルカードは様々な効果を持つことができます。
    - 回復：HPを回復する
    - カードドロー：追加でカードを引く
    - バフ：自分を強化する
    - デバフ：敵を弱体化する
    など
    
    この実装では「効果関数」を渡すことで、柔軟に効果を定義できます。
    """
    
    def __init__(self, name, description, cost, effect_function):
        """
        スキルカードのコンストラクタ
        
        【引数の説明】
        - name: カードの名前
        - description: カードの説明文
        - cost: 使用コスト
        - effect_function: カードの効果を実行する関数
        
        【effect_functionについて】
        Pythonでは関数も値として扱えるため、関数を変数に代入したり、
        引数として渡したりできます。これを「第一級関数」と呼びます。
        
        effect_function は以下の形式の関数を期待しています：
        def 効果関数(user, target):
            # 効果の処理
            return "効果のメッセージ"
        
        【実行内容】
        1. 親クラス（Card）のコンストラクタを呼び出す
        2. 効果関数を保存する
        """
        super().__init__(name, description, cost, CardType.SKILL)
        # 効果関数を保存（後で use() メソッド内で呼び出す）
        self.effect_function = effect_function
    
    def use(self, user, target):
        """
        スキルカードを使用するメソッド
        
        【実行内容】
        保存しておいた effect_function を呼び出して、
        その結果（メッセージ）を返します。
        """
        # self.effect_function(user, target) で効果関数を呼び出す
        # 関数を変数に保存していても、() を付ければ呼び出せます
        return self.effect_function(user, target)


# =============================================================================
# カードを生成するヘルパー関数
# =============================================================================
def create_starting_deck():
    """
    ゲーム開始時のデッキ（カードの束）を作成する関数
    
    【解説】
    この関数は、新しいゲームを開始するときに呼び出されます。
    プレイヤーに最初から持たせるカードのリストを作成して返します。
    
    【戻り値】
    - list: Card オブジェクトのリスト（デッキ）
    
    【実行内容】
    1. 空のリストを作成
    2. 基本的なカードを追加
    3. 完成したデッキを返す
    """
    # 空のリストを作成
    deck = []
    
    # ----- 攻撃カードを追加 -----
    # range(4) は 0, 1, 2, 3 の4回ループします
    # _（アンダースコア）は「使わない変数」を示す慣習です
    for _ in range(4):
        # AttackCard のインスタンスを作成してデッキに追加
        strike = AttackCard(
            name="ストライク",               # カードの名前
            description="敵に6ダメージを与える",  # カードの説明
            cost=1,                          # 使用コスト
            damage=6                         # ダメージ量
        )
        deck.append(strike)  # リストに追加
    
    # ----- 防御カードを追加 -----
    for _ in range(4):
        defend = DefendCard(
            name="ディフェンド",
            description="5ブロックを得る",
            cost=1,
            block=5
        )
        deck.append(defend)
    
    # ----- スキルカードを追加 -----
    # 回復カードの効果関数を定義
    # lambda は無名関数（名前のない関数）を作成する方法です
    # lambda 引数: 戻り値 の形式で書きます
    heal_effect = lambda user, target: heal_function(user, 5)
    
    heal_card = SkillCard(
        name="応急手当",
        description="HPを5回復する",
        cost=1,
        effect_function=heal_effect
    )
    deck.append(heal_card)
    
    # カードドローカードの効果関数
    # このカードは後でゲームループ側で特別に処理する必要があります
    draw_effect = lambda user, target: f"{user.name}はカードを2枚引いた！"
    
    draw_card = SkillCard(
        name="戦術思考",
        description="カードを2枚引く",
        cost=1,
        effect_function=draw_effect
    )
    deck.append(draw_card)
    
    # 完成したデッキを返す
    return deck


def heal_function(user, amount):
    """
    回復効果を実行するヘルパー関数
    
    【引数の説明】
    - user: 回復するキャラクター
    - amount: 回復量
    
    【戻り値】
    - 文字列: 回復結果のメッセージ
    
    【実行内容】
    1. キャラクターのHPを回復する
    2. 結果メッセージを返す
    
    【解説】
    なぜlambda内で直接user.heal()を呼ばないのか？
    → コードを読みやすくするためと、回復処理を一箇所にまとめるためです。
    """
    user.heal(amount)
    return f"{user.name}はHPを{amount}回復した！"


# =============================================================================
# テスト用コード
# =============================================================================
# このブロックは、このファイルを直接実行したときだけ実行されます。
# 他のファイルからインポートされたときは実行されません。
#
# __name__ は特殊変数で、ファイルの実行方法によって値が変わります：
# - 直接実行された場合: "__main__"
# - インポートされた場合: モジュール名（例: "card"）
if __name__ == "__main__":
    # テスト用のコードをここに書きます
    print("=== カードクラスのテスト ===")
    
    # 攻撃カードを作成してテスト
    test_attack = AttackCard("テスト攻撃", "10ダメージ", 1, 10)
    print(test_attack)  # __str__ メソッドが呼ばれる
    
    # 防御カードを作成してテスト
    test_defend = DefendCard("テスト防御", "5ブロック", 1, 5)
    print(test_defend)
    
    # 初期デッキを作成してテスト
    print("\n=== 初期デッキの内容 ===")
    deck = create_starting_deck()
    for i, card in enumerate(deck, 1):
        # enumerate(deck, 1) は、1から始まる番号付きでループします
        print(f"{i}. {card}")
